import{u,r as i,j as e}from"./index-BQ6reGTr.js";import{H as b,t as h}from"./index-DNGCOx9y.js";const l=({code:s,language:a="typescript"})=>{const{isDarkMode:c}=u();return e.jsx(b,{theme:c?h.nightOwl:h.github,code:s,language:a,children:({className:o,style:n,tokens:d,getLineProps:t,getTokenProps:m})=>e.jsx("pre",{className:o,style:n,children:d.map((r,x)=>e.jsx("div",{...t({line:r}),children:r.map((j,p)=>e.jsx("span",{...m({token:j})},p))},x))})})},v=(s,a)=>{console.time("filter array");const c=s.filter(o=>a==="all"?!0:o.includes(a));return console.timeEnd("filter array"),c},f=()=>{const{isDarkMode:s}=u(),[a]=i.useState(["Learn React","Build app","Deploy","Celebrate"]),[c,o]=i.useState("all"),[n,d]=i.useState(0),t=i.useMemo(()=>v(a,c),[a,c]);return e.jsxs("div",{className:`useState-container ${s?"dark":"light"}`,children:[e.jsxs("header",{className:`useState-header ${s?"dark":"light"}`,children:[e.jsx("h1",{children:"ğŸ’¾ useMemo Hook"}),e.jsx("p",{className:"subtitle",children:"Guardar en cachÃ© el resultado de un cÃ¡lculo entre renderizados."})]}),e.jsxs("section",{className:"section",children:[e.jsx("h2",{children:"ğŸ“š Â¿QuÃ© es useMemo?"}),e.jsxs("div",{className:"card",children:[e.jsxs("p",{children:[e.jsx("code",{children:"useMemo"})," te permite memoizar (guardar en cachÃ©) el resultado de un cÃ¡lculo costoso entre renderizados, evitando recalcularlo innecesariamente."]}),e.jsxs("div",{className:"highlight-box",children:[e.jsx("strong",{children:"âœ¨ Importante:"})," Ãšsalo solo para cÃ¡lculos costosos. La mayorÃ­a de cÃ¡lculos son muy rÃ¡pidos y no requieren memoizaciÃ³n."]})]})]}),e.jsxs("section",{className:"section",children:[e.jsx("h2",{children:"ğŸ¯ Sintaxis"}),e.jsx("div",{className:"code-block",children:e.jsx(l,{language:"typescript",code:`const cachedValue = useMemo(calculateValue, dependencies)

import { useMemo } from "react"

function TodoList({ todos, tab }) {
  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab])
  // ...
}`})}),e.jsxs("div",{className:"card",children:[e.jsx("h3",{children:"ParÃ¡metros"}),e.jsxs("ul",{className:"anatomy-list",children:[e.jsxs("li",{children:[e.jsx("span",{className:"param",children:"calculateValue"})," - La funciÃ³n que calcula el valor que deseas memoizar. Debe ser pura y no recibir argumentos."]}),e.jsxs("li",{children:[e.jsx("span",{className:"param",children:"dependencies"})," - La lista de todos los valores reactivos a los que se hace referencia dentro del cÃ³digo calculateValue. Los valores reactivos incluyen props, estado y todas las variables y funciones declaradas directamente dentro del cuerpo de tu componente."]})]})]})]}),e.jsxs("section",{className:"section",children:[e.jsx("h2",{children:"ğŸš€ Evitar recÃ¡lculos costosos"}),e.jsx("div",{className:"card",children:e.jsx("p",{children:"Por lo general, esto no es un problema porque la mayorÃ­a de los cÃ¡lculos son muy rÃ¡pidos. Sin embargo, si estÃ¡s filtrando o transformando un array grande, o estÃ¡s realizando algÃºn cÃ¡lculo costoso, es posible que desees omitir hacerlo nuevamente si los datos no han cambiado."})}),e.jsxs("div",{className:"demo-card",children:[e.jsxs("div",{className:"demo-display",children:[e.jsxs("div",{className:"demo-value",children:[e.jsx("span",{className:"label",children:"Tab activo:"}),e.jsx("span",{className:"value",children:c})]}),e.jsxs("div",{className:"demo-value",children:[e.jsx("span",{className:"label",children:"Contador:"}),e.jsx("span",{className:"value",children:n})]})]}),e.jsxs("div",{style:{display:"flex",gap:"0.5rem",flexWrap:"wrap",marginBottom:"1rem"},children:[e.jsx("button",{className:"btn-primary",onClick:()=>o("all"),children:"All"}),e.jsx("button",{className:"btn-secondary",onClick:()=>o("React"),children:"React"}),e.jsxs("button",{className:"btn-secondary",onClick:()=>d(n+1),children:["Increment (",n,")"]})]}),e.jsxs("div",{style:{padding:"1rem",borderRadius:"8px",background:"rgba(102, 126, 234, 0.1)"},children:[e.jsx("strong",{children:"Filtered Todos:"}),e.jsx("ul",{children:t.map((m,r)=>e.jsx("li",{children:m},r))}),e.jsx("p",{style:{fontSize:"0.9rem",marginTop:"0.5rem"},children:'Abre la consola y ve que solo se recalcula cuando cambia "tab"'})]})]}),e.jsxs("div",{className:"info-box",children:[e.jsx("strong",{children:"ğŸ’¡ Nota:"})," Al incrementar el contador, el cÃ¡lculo NO se ejecuta de nuevo porque ",e.jsx("code",{children:"todos"})," y ",e.jsx("code",{children:"tab"})," no cambiaron."]})]}),e.jsxs("section",{className:"section",children:[e.jsx("h2",{children:"â±ï¸ Â¿CÃ³mo saber si un cÃ¡lculo es costoso?"}),e.jsx("div",{className:"card",children:e.jsx("p",{children:"Puedes medir el tiempo dedicado a una pieza de cÃ³digo:"})}),e.jsx("div",{className:"code-block",children:e.jsx(l,{language:"typescript",code:`console.time("filter array")
const visibleTodos = filterTodos(todos, tab)
console.timeEnd("filter array")`})}),e.jsxs("div",{className:"info-box",children:[e.jsx("strong",{children:"ğŸ’¡ Regla general:"})," Si el cÃ¡lculo toma mÃ¡s de 1ms, podrÃ­a tener sentido memoizarlo."]})]}),e.jsxs("section",{className:"section",children:[e.jsx("h2",{children:"ğŸ”„ Evitando que un efecto se ejecute con frecuencia"}),e.jsx("div",{className:"code-block",children:e.jsx(l,{language:"typescript",code:`function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  const options = useMemo(() => {
    return {
      serverUrl: 'https://localhost:1234',
      roomId: roomId
    };
  }, [roomId]); // âœ… Solo cambia cuando roomId cambia

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // âœ… Solo cambia cuando options cambia
  // ...
}`})}),e.jsxs("div",{className:"success-card",children:[e.jsx("h3",{children:"âœ… Alternativa mejor: Pasar objeto directamente"}),e.jsx("div",{className:"code-block",children:e.jsx(l,{language:"typescript",code:`function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = { // âœ… Â¡No necesitas useMemo o dependencias de objetos!
      serverUrl: 'https://localhost:1234',
      roomId: roomId
    }

    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // âœ… Solo cambia cuando roomId cambia
  // ...
}`})})]}),e.jsxs("div",{className:"info-box",children:[e.jsx("strong",{children:"ğŸ’¡ Best Practice:"})," Cuando sea posible, es mejor mover objetos y funciones dentro del efecto para evitar tener que incluirlos como dependencias."]})]}),e.jsxs("section",{className:"section",children:[e.jsx("h2",{children:"ğŸ”„ Diferencia: useMemo vs useCallback"}),e.jsx("div",{className:"table-container",children:e.jsxs("table",{className:"methods-table",children:[e.jsx("thead",{children:e.jsxs("tr",{children:[e.jsx("th",{children:"CaracterÃ­stica"}),e.jsx("th",{children:"useMemo"}),e.jsx("th",{children:"useCallback"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{children:e.jsx("strong",{children:"Â¿QuÃ© cachea?"})}),e.jsx("td",{children:"El resultado de una funciÃ³n"}),e.jsx("td",{children:"La funciÃ³n misma"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:e.jsx("strong",{children:"Sintaxis"})}),e.jsx("td",{children:e.jsx("code",{children:"useMemo(() => fn(), deps)"})}),e.jsx("td",{children:e.jsx("code",{children:"useCallback(fn, deps)"})})]}),e.jsxs("tr",{children:[e.jsx("td",{children:e.jsx("strong",{children:"CuÃ¡ndo usar"})}),e.jsx("td",{children:"CÃ¡lculos costosos"}),e.jsx("td",{children:"Pasar funciones a componentes memoizados"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:e.jsx("strong",{children:"Equivalencia"})}),e.jsx("td",{children:e.jsx("code",{children:"useMemo(() => fn, deps)"})}),e.jsx("td",{children:e.jsx("code",{children:"useCallback(fn, deps)"})})]})]})]})})]}),e.jsxs("section",{className:"section",children:[e.jsx("h2",{children:"ğŸ’¡ Tips y Best Practices"}),e.jsxs("div",{className:"tips-grid",children:[e.jsxs("div",{className:`tip-card ${s?"dark":"light"}`,children:[e.jsx("span",{className:"tip-icon",children:"â±ï¸"}),e.jsx("h3",{children:"Mide primero"}),e.jsx("p",{children:"No uses useMemo prematuramente. Mide el rendimiento antes de optimizar"})]}),e.jsxs("div",{className:`tip-card ${s?"dark":"light"}`,children:[e.jsx("span",{className:"tip-icon",children:"ğŸ¯"}),e.jsx("h3",{children:"CÃ¡lculos costosos"}),e.jsx("p",{children:"Ãšsalo solo para cÃ¡lculos que toman mÃ¡s de 1ms"})]}),e.jsxs("div",{className:`tip-card ${s?"dark":"light"}`,children:[e.jsx("span",{className:"tip-icon",children:"ğŸ“¦"}),e.jsx("h3",{children:"Objetos y arrays"}),e.jsx("p",{children:"Ideal para evitar crear nuevos objetos en cada render"})]}),e.jsxs("div",{className:`tip-card ${s?"dark":"light"}`,children:[e.jsx("span",{className:"tip-icon",children:"ğŸ”„"}),e.jsx("h3",{children:"Con useEffect"}),e.jsx("p",{children:"Ãštil para memoizar dependencias de efectos"})]}),e.jsxs("div",{className:`tip-card ${s?"dark":"light"}`,children:[e.jsx("span",{className:"tip-icon",children:"ğŸš«"}),e.jsx("h3",{children:"No abuses"}),e.jsx("p",{children:"La mayorÃ­a de cÃ¡lculos son rÃ¡pidos y no necesitan memoizaciÃ³n"})]}),e.jsxs("div",{className:`tip-card ${s?"dark":"light"}`,children:[e.jsx("span",{className:"tip-icon",children:"ğŸ¨"}),e.jsx("h3",{children:"Arrays grandes"}),e.jsx("p",{children:"Perfecto para filtrar o transformar grandes cantidades de datos"})]})]})]})]})};export{f as default};
